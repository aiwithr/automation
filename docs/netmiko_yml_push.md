আপনার এক বন্ধু আছে উজ্জল। সে একটা বড় টেলিকম কোম্পানিতে নেটওয়ার্ক স্পেশালিস্ট। একদিন অফিসে যাবার পর তার বস বলল, "উজ্জল, আমাদের কাস্টমারের ৫০০টা রাউটারে নতুন কনফিগারেশন দিতে হবে। কাল সকালের মধ্যে চাই।"

উজ্জল প্রথমে একটু ঘাবড়ে গেল। মনে মনে হিসাব করল - প্রতি রাউটারে ১০ মিনিট, ৫০০টা রাউটার, মোট লাগবে ৮৩ ঘণ্টা! কিন্তু উজ্জল হাল ছাড়ল না। আসলে সে জানে এই কাজটা অটোমেট করে ১৫ মিনিটেই শেষ করা যায়।

### টেমপ্লেট ব্যবহার করে লুপব্যাক ইন্টারফেস যোগ

এই কাজে আমরা YAML, Jinja2 এবং Netmiko একসাথে ব্যবহার করে লুপব্যাক ইন্টারফেস কনফিগার করব। এটা পারলেই সব কিছু পুশ করতে পারবেন। খালি কনফিগারেশন পাল্টে দেবেন।

### প্রজেক্ট স্ট্রাকচার 

এবার আমাদের ফাইলগুলো সুন্দর করে সাজিয়ে রাখি;
```
network_automation/
│
├── configs/               # কনফিগারেশন ফাইল
│   ├── routers.yml
│   └── interfaces.yml
│
├── templates/            # টেমপ্লেট ফাইল
│   └── loopback.j2
│
├── scripts/             # পাইথন স্ক্রিপ্ট
│   └── deploy.py
│
└── logs/               # লগ ফাইল (পৃষ্টার লিমিটেশনের জন্য দেখাইনি)
    └── automation.log
```    
## প্রথম ধাপ: প্রস্তুতি

প্রথমে আমরা পাইথনে প্রয়োজনীয় টুল ইনস্টল করব:

```bash
# প্রথমে পাইথন ভার্চুয়াল এনভায়রনমেন্ট তৈরি করি 
python -m venv network_env
source network_env/bin/activate

# এরপর প্রয়োজনীয় লাইব্রেরি ইনস্টল করি
pip install netmiko pyyaml jinja2
```

## দ্বিতীয় ধাপ: ডাটা সাজানো 

এবার আমাদের রাউটারের ডাটা সাজিয়ে রাখব একটা ফাইলে (routers.yml):

```yaml
routers:
  - name: dhaka_router_1
    ip: 192.168.1.1
    username: admin
    password: secure123
    type: cisco_ios
```

আর নতুন কনফিগারেশন লিখব আরেক ফাইলে (interfaces.yml):

```yaml
interfaces:
  loopback:
    number: 0
    description: Management Interface
    ip: 10.0.0.1
    mask: 255.255.255.0
```

## তৃতীয় ধাপ: টেমপ্লেট তৈরি

এবার কমান্ডের জিনজা টেম্পলেট বানাব (template.j2):

```jinja2
interface Loopback{{ interface.number }}
 description {{ interface.description }}
 ip address {{ interface.ip }} {{ interface.mask }}
 no shutdown
```

## চতুর্থ ধাপ: স্ক্রিপ্ট লেখা

এবার মূল স্ক্রিপ্ট (deploy.py):

ভয় পাবেন না। আমি প্রতিটি লাইন ধরে ধরে ব্যাখ্যা করছি বলেই বড় লাগছে; (আসলে একটা একটা ছোট এবং সহজ স্ক্রিপ্ট) 

```python
# প্রথমে আমাদের প্রয়োজনীয় লাইব্রেরি ইমপোর্ট করছি
import yaml                                    # YAML ফাইল পড়ার জন্য
from jinja2 import Environment, FileSystemLoader    # টেমপ্লেট ব্যবহারের জন্য
from netmiko import ConnectHandler            # রাউটারে কানেক্ট করার জন্য

def main():
    # প্রথম ধাপ: YAML ফাইল থেকে তথ্য পড়া
    # 'configs/routers.yml' থেকে রাউটারের তথ্য পড়ছি
    with open('configs/routers.yml') as f:
        routers = yaml.safe_load(f)           # YAML ফাইল পাইথন ডিকশনারিতে কনভার্ট করছি
    
    # 'configs/interfaces.yml' থেকে ইন্টারফেস কনফিগারেশন পড়ছি
    with open('configs/interfaces.yml') as f:
        configs = yaml.safe_load(f)           # এটাও পাইথন ডিকশনারিতে কনভার্ট হচ্ছে
    
    # দ্বিতীয় ধাপ: জিনজা টেমপ্লেট সেটআপ
    # 'templates' ফোল্ডার থেকে টেমপ্লেট লোড করার জন্য এনভায়রনমেন্ট তৈরি
    env = Environment(loader=FileSystemLoader('templates'))
    
    # 'template.j2' ফাইল লোড করছি
    template = env.get_template('template.j2')
    
    # টেমপ্লেটে ভ্যারিয়েবল বসিয়ে কনফিগারেশন তৈরি করছি
    config = template.render(interface=configs['interfaces']['loopback'])
    
    # তৃতীয় ধাপ: প্রতিটি রাউটারে কাজ করা
    for router in routers['routers']:         # প্রতিটি রাউটার একে একে নিচ্ছি
        print(f"\n{router['name']} এ কাজ শুরু...")  # স্টাটাস মেসেজ
        
        # নেটমিকো দিয়ে রাউটারে কানেক্ট করছি
        connection = ConnectHandler(**router)  # router ডিকশনারি থেকে সব প্যারামিটার পাঠাচ্ছি
        
        # কনফিগারেশন পাঠাচ্ছি - আগে newline দিয়ে ভাগ করে নিলাম
        output = connection.send_config_set(config.split('\n'))
        
        print(f"{router['name']} এ কাজ শেষ!")  # সফল হওয়ার মেসেজ
        
        connection.disconnect()                # কানেকশন বন্ধ করে দিচ্ছি

# স্ক্রিপ্ট সরাসরি রান করা হলে main() ফাংশন কল করা
if __name__ == "__main__":
    main()
```

!!! tldr "পাইথন প্র্যাকটিস"
    `if __name__ == "__main__"` এই লাইনটি পাইথনে একটি কমন প্র্যাকটিস। এটি নিশ্চিত করে যে `main()` ফাংশন তখনই কেবল কল হবে যখন স্ক্রিপ্টটি সরাসরি রান করা হয়। অন্য কোনও স্ক্রিপ্টে এটিকে ইম্পোর্ট করলে `main()` অটোমেটিক কল হবে না।

    এটি আপনার কোড স্ট্রাকচারকে অর্গানাইজড রাখতে সাহায্য করে। একই প্রজেক্টের বিভিন্ন স্ক্রিপ্টে ব্যবহারের জন্য আপনি শুধু প্রয়োজনীয় ফাংশন লিখতে পারেন, আর `if __name__ == "__main__"` এর মধ্যে শুধু সেই কোডটুকু রাখতে পারেন যা শুধুমাত্র এই স্ক্রিপ্টটির জন্য প্রযোজ্য।

    সংক্ষেপে, `__name__` একটি স্পেশাল ভ্যারিয়েবল যার মান নির্ভর করে স্ক্রিপ্টটি কীভাবে এক্সিকিউট হচ্ছে তার উপর। সরাসরি রান করলে এর মান হয় `"__main__"`, আর ইম্পোর্ট করলে মডিউলের নাম। আপনি এই লজিক ব্যবহার করে আপনার কোডের ফ্লো কন্ট্রোল করতে পারেন।

deploy.py স্ক্রিপ্ট তিনটি মূল ধাপে কাজ করছে:

১. **ডাটা লোডিং**: YAML ফাইল থেকে রাউটার এবং কনফিগারেশনের তথ্য পড়ছে। এটা করার জন্য PyYAML লাইব্রেরি ব্যবহার করছে।

২. **টেমপ্লেট প্রসেসিং**: Jinja2 টেমপ্লেট এনজিন ব্যবহার করে টেমপ্লেট ফাইল থেকে বাস্তব কনফিগারেশন কমান্ড তৈরি করছে।

৩. **কনফিগারেশন ডেপ্লয়মেন্ট**: Netmiko ব্যবহার করে প্রতিটি রাউটারে SSH কানেকশন করে কনফিগারেশন পাঠাচ্ছে।

## শেষ ধাপ: স্ক্রিপ্ট চালানো

এবার শুধু কমান্ড দিলেই কাজ শেষ:

```bash
python deploy.py
```

এভাবে উজ্জল ৮৩ ঘণ্টার কাজ ১৫ মিনিটে শেষ করল। কিন্তু এর আগে সে কিছু সতর্কতা অবলম্বন করল:

১. টেস্টিং এনভায়রনমেন্টে প্রথমে পরীক্ষা করল
২. সব রাউটারের ব্যাকআপ নিয়ে রাখল
৩. যে কমান্ড পাঠাবে তা আগে ভাল করে চেক করল

এভাবে সে নিশ্চিত হল যে কোন ভুল হবে না। আপনিও চাইলে এই পদ্ধতি ব্যবহার করে আপনার কাজ সহজ করে ফেলতে পারেন!

!!! tips "ইচ্ছেকৃত ভুল"
    কাজটা করতে গিয়ে ছোট একটা ভুল করে রেখেছি, কাজ করলেই বুঝতে পারবেন। তবে, সেটা গিটহাবে দেয়া আছে।

