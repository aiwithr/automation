## পাইথন দিয়ে নেটওয়ার্কের কনফিগারেশন ব্যাকআপ

আগের চ্যাপ্টারে আমরা পাইথন নিয়ে কিছুটা আলাপ করেছি। আমি চেষ্টা করেছি এখানে যতটুকু পাইথন লাগবে সেটাই কাভার করা এর থেকে বেশী নয়। পাইথন স্ট্রিট দিয়ে আমাদের নেটওয়ার্ক ডিভাইসে এসএসএইচ (SSH) দিয়ে ঢুকে সেখান থেকে কনফিগারেশন ফাইলগুলোকে কপি করে ব্যাকআপ করব আমাদের নির্দিষ্ট কম্পিউটারে। 

শুরুতে এটাকে খুবই সাধারণ একটা বেসিক স্ক্রিপটে রাখছি ইচ্ছে করে যার মধ্যে কোন ডেড টাইম স্টাম্পিং থাকছে না অথবা বিভিন্ন ম্যানুফ্যাকচারার যেমন শুষ্ক জুনিপার মাইক্রোটিক হুয়াওয়ে এতগুলো না রেখে একটা ম্যানুফ্যাকচারার সিলেক্ট করেছি। এর পাশাপাশি স্ক্রিপ্ট টাকে ইন্টেলিজেন্ট করার জন্য বিভিন্ন এর হ্যান্ডলিং অথবা প্যারালাল ভাবে আরো কিছু অপারেশন চালানোর মত দক্ষতা নিয়ে আলাপ করব সামনে। এখানে এডভান্সড লেভেলের স্ক্রিপ্ট তৈরি করা যায় তবে আমরা যদি বেসিক ফাউন্ডেশনাল টুল হিসাবে এটা না বুঝি তাহলে সামনে আরো ভেতরে ঢোকা দুষ্কর হবে।

আমরা আগেই বলেছি পাইথনের বিউটি হচ্ছে এর প্রচুর হেল্পার লাইব্রেরী আছে যার মাধ্যমে বড় বড় অপারেশনের অনেক কমপ্লেক্স সিটি হাইড করে রাখে আমাদের মত নতুন অটোমেশন এক্সপার্টদের কাছ থেকে। সেরকম একটা হেল্পার লাইব্রেরী হচ্ছে নেটমিকো। অনেকে প্যারামিকোর কথা বলবেন, তবে নেটমিক ো প্যারামিকোর উপরের ভিত্তি করে তৈরি করা, এবং নেট নিকোতে অনেক এডভান্সড ফিচার আছে যেটা প্যারামিকোর অনেক কমপ্লেক্সসিটি লুকিয়ে রাখতে পারে।

## নেটমিকো কি?

আমাদের ল্যাপটপ বা পিসি থেকে নেট মিকো লাইব্রেরী ব্যবহার করে কয়েকটা ডিভাইসে কানেক্ট করব, একটা ফর লুব ব্যবহার করে। নেট মিকো হচ্ছে একটা পাইথন লাইব্রেরী যেটা একটা নেটওয়ার্কের ভিতরে ব্যবহৃত বিভিন্ন ম্যানুফ্যাকচারারের ডিভাইসে কিভাবে সহজে অটমেশন করা যায় সেটাই দেখাবো এখানে। মোদ্দা কথায় এর কাজ হচ্ছে একটা ইউনিফাই ড ইন্টারফেস তৈরি করা যাতে আমরা সরাসরি বিভিন্ন ধরনের ডিভাইসের সাথে ইন্টারেক্ট করতে পারি। চলুন শুরুতে নেট মিকো ইনস্টল করে নেই, পাইথনের পিপ প্যাকেজ ম্যানেজার দিয়ে।

``` py title="ইনস্টল করি"
pip install netmiko
```

আমাদের এই স্ক্রিপ্ট শুরু হচ্ছে দুটো মডিউলকে ইমপোর্ট করে। একটা হচ্ছে নেট মিকো, যার কাজ হচ্ছে এসএসএইচ কানেকশন তৈরি করে দেবে আমাদের তিনটা নেটওয়ার্ক ডিভাইসের সাথে। এর পাশাপাশি গেট পাস মডিউলের কাজ হচ্ছে পাসওয়ার্ড প্রম্পটকে কিভাবে নিরাপদ ভাবে আমাদের কাছ থেকে নিয়ে এই স্ক্রিপ্টের ব্যবহার করবে। আমরা অন্য আরেকটা সিকিউট জায়গা থেকে পাসওয়ার্ড নিয়ে আসতে পারতাম তবে সেটা বেসিক স্ক্রিপ্টে রাখছি না শুরুতে।

``` py title="ইনস্টল করি"
from netmiko import ConnectHandler
import getpass
```

স্ক্রিপ্ট এর শুরুতে একটা পাসওয়ার্ড দেবার ফ্রম আসবে, যেটা ব্যবহার করবে একটা গেট পাস ফাংশন। এই গেট পাস ফাংশনের কাজ হচ্ছে আমাদের পাসওয়ার্ড কে নিরাপদ ভাবে ক্যাপচার করে ডিভাইস গুলোর সাথে ইন্টারেক্ট করবে। নিরাপত্তা পলিসি হিসেবে পাসওয়ার্ড নেবার সময় পাসওয়ার্ড ইনপুট স্ক্রিনে ডিসপ্লে করবে না।

``` py title="ইনস্টল করি"
passwd = getpass.getpass('Please enter the password: ')
```

স্ক্রিপ্টের এই পর্যায় আমাদেরকে বলে দিতে হবে কোথায় কনফিগারেশন ব্যাকআপ গুলো স্টোর হবে আমাদের পিসিতে। এটা একটা সেন্ট্রাল কনফিগারেশন সার্ভারে স্টোর করা যেত তবে কমপ্লেক্সিটি এড়ানোর কারণে আমরা এই মুহূর্তে সেটাকে রাখছি আমাদের পিসিতে। এই স্ক্রিপ্টটা শুরুতে তৈরি করছে একটা খালি লিস্ট যার নাম হচ্ছে device list।

``` py title="ইনস্টল করি"
file_dir = '/Users/suresh/Documents/config-backup/backups'
switch_list = ['192.168.10.10', 'core-switch-01', 'test_switch']
device_list = []
```
এই তালিকা পরে পপুলেটেড হয়ে যাবে ডিকশনারি দিয়ে যেখানে প্রতিটা জিনিস রিপ্রেজেন্ট করবে একেকটা নেটওয়ার্ক ডিভাইস। এই ডিকশনারি টার মধ্যে একটা কি ভ্যালু পেয়ার থাকবে যেটা এস এস এইচ কানেকশনের জন্য প্রয়োজনীয় ডিটেইল সংরক্ষণ করবে। যেমন এখানে ডিভাইস টাইপ পোস্ট আইপি ইউজারনেম পাসওয়ার্ড অথবা সিক্রেট এনাবল পাসওয়ার্ড ইত্যাদি ডিকশনারি তে রেখে দিবে।

``` py title="ইনস্টল করি"
for ip in switch_list:
    device = {
        "device_type": "cisco_ios",
        "host": ip,
        "username": "nabeel",
        "password": passwd,
        "secret": passwd # Enable password
    }
    device_list.append(device)
```

সুইচ লিস্ট থেকে আইপি এড্রেস, সুইচ এর নাম ধরে লুপ করার পরে সেটা একটা ডিকশনারি তৈরি করবে যার মধ্যে এস এস ডিটেলস থাকবে প্রতিটা ডিভাইসের জন্য এবং এরপর সেটাকে অ্যাপেন্ড করা হবে ডিভাইস লিস্টে। যখন এসএসসাইজ ডিটেল গুলো তৈরি হয়ে গেছে তখন সেই স্ক্রিপটা ডিভাইস লিস্ট ধরে গ্রুপ করবে যাতে প্রতিটা এস এস এইচ কানেকশন প্রতিটা ডিভাইসের জন্য কানেকশন হ্যান্ডেলের ক্লাস ব্যবহার করবে নেট মিকো লাইব্রেরী থেকে।

``` py title="ইনস্টল করি"
for device in device_list:
    host_name = device['host']
    connection = ConnectHandler(**device)
    show_run = connection.send_command('show run')
```

উপরের শেষের লাইনে, ডিভাইসে কানেক্টেড হবার পরে প্রতিটা ডিভাইসে আলাদা আলাদা করে শো রান কমান্ড পাঠাবে যাতে সেই device গুলো থেকে রানিং কনফিগারেশন ফাইলগুলো সে পড়তে পারে। এই রানিং কনফিগারেশন গুলোকে সে স্টোর করবে ভেরিয়েবল শো রান অংশে। এরপরে ই ফাইল-ডায়ের বলে একটা ব্যাকআপ ডাইরেক্ট ফ্রিতে একটি নতুন ফাইল তৈরি করবে যেখানে ফাইলটার নাম রাখা হয়েছে সুরান হোস্ট নেম ডট টেক্সট ফাইল। ডিভাইসের রানিং কনফিগারেশন ফাইলের আউটপুট রাইট হবে এই ফাইলটাতে। 

``` py title="ইনস্টল করি"
    with open(f"{file_dir}/show_run_{host_name}.txt", 'w') as f:
            f.write(show_run)
```
ব্যাকিং আপ কমপ্লিট হওয়ার পরে এই স্ক্রিপ্ট পরবর্তী ডিভাইসে যাবার আগে আগে ডিভাইস থেকে ডিসকানেক্ট হয়ে যাবে। পরবর্তী ডিভাইসটি নেওয়া হবে ডিভাইস লিস্ট থেকে।

``` py title="ইনস্টল করি"
    connection.disconnect()
```

কোথায় ইনহান্সমেন্ট আসতে পারে?

১. কন কারেন্সি: এই স্ক্রিপ্টে প্রতিটা ডিভাইস একটার পর একটা কানেক্ট করে তার কনফিগারেশন ফাইল ব্যাকআপ করা হবে। তবে এই অপারেশন এ গতি আনার জন্য এখানে কোন কারেন্সি ফিচার আনা যেতে পারে। কন কারেন্সি ফিচার পাইথনের মডিউল হিসেবে এই স্ক্রিপ্ট টাকে কনফারেন্ট হিসাবে চালাতে পারে। এখানে পাইথন প্রতিটা ডিভাইস শেষ করার পর পরবর্তী ডিভাইসে যাবার পরিবর্তে একেবারে প্রতিটা ডিভাইসে কানেকশন তৈরি করে কনফিগারেশন ফাইলগুলো কপি করে আনতে পারে।

২. এরর হ্যান্ডলিং: ডিভাইসে কানেকশন তৈরি করে কাজ করার সময় যদি স্ক্রিপ্ট কখনো ফেল করে তাহলে পুরো প্রসেস ক্রাশ করে যেতে পারে। এ কারণে এর মধ্যে ট্রাই অথবা একসেপ্ট ক্লোজ যোগ করলে পাইথন সিদ্ধান্ত নিবে কোন ধরনের এরর হলে তাহলে পরবর্তী ডিভাইসে সে চলে যাবে। ভালো এরোর handing প্রসিজিউর থাকলে আমাদের স্ক্রিপ্ট গুলো আরো বেশি বুদ্ধিমান হবে যাতে যে কোন সমস্যাতে যাতে স্ক্রিপ্ট রিকভার করতে পারে।

৩. গিট ের ভার্সন কন্ট্রোল ইন্টিগ্রেশন: কনফিগারেশন ব্যাকআপ রাখতে গিয়ে প্রতিটা কনফিগারেশনের কি ধরনের পরিবর্তন হচ্ছে সেটার জন্য ট্রাক রাখা জরুরী। এই স্ক্রিপ্টের ইনহেসমেন্ট আনা যায় যদি আমরা গিট এর মত একটা ভার্সন কন্ট্রোল সিস্টেম যোগ করে দিতে পারি। এতে প্রতিটা কনফিগারেশন ফাইলের পরিবর্তন ট্র্যাক করা সম্ভব হবে। কখনো যদি কোন সমস্যা হয় তাহলে আমরা এর আগের ওয়ার্কিং কনফিগারেশন ফাইলে ফেরত যেতে পারি যাতে নেটওয়ার্ক এ ডাউন টাইম কম থাকে।

